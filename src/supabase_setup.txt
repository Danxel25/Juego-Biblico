-- #############################################################################
-- #                                                                           #
-- #             SCRIPT DE CONFIGURACIÓN PARA SUPABASE DATABASE                #
-- #                                                                           #
-- #############################################################################
--
-- Instrucciones:
-- 1. Ve al "SQL Editor" en tu proyecto de Supabase.
-- 2. Haz clic en "+ New query".
-- 3. Copia TODO el contenido de este archivo.
-- 4. Pégalo en el editor de SQL.
-- 5. Haz clic en "RUN".
--
-- Esto configurará todas las tablas, funciones y políticas de seguridad
-- necesarias para que la aplicación funcione correctamente.

-- ========= HABILITAR EXTENSIÓN PARA UUID =========
create extension if not exists "uuid-ossp";

-- ========= TABLA DE USUARIOS (PERFILES PÚBLICOS) =========
-- Almacena información pública del perfil de cada usuario.
-- Esta tabla incluye todas las columnas para una configuración nueva.
create table if not exists public.users (
  uid uuid not null primary key, -- Coincide con auth.users.id
  email text,
  custom_name text,
  country text,
  gender text,
  date_of_birth date,
  marital_status text,
  avatar_url text,
  motto_verse jsonb,
  level integer default 1,
  xp integer default 0,
  title text,
  fe integer default 100,
  talents integer default 10,
  consumables jsonb default '{}'::jsonb,
  is_guest boolean default false,
  friends uuid[] default array[]::uuid[],
  friend_requests_sent uuid[] default array[]::uuid[],
  friend_requests_received uuid[] default array[]::uuid[],
  unlocked_achievements text[] default array[]::text[],
  duels_won integer default 0,
  correct_answers integer default 0,
  current_streak integer default 0,
  last_login date default current_date
);

-- MODIFICACIÓN PARA ASEGURAR QUE LAS NUEVAS COLUMNAS EXISTAN
-- Para usuarios que ya tenían la tabla 'users' creada, esto asegura que se actualice.
-- Se ejecuta de forma segura gracias a 'IF NOT EXISTS' y no borra datos.
alter table public.users add column if not exists country text;
alter table public.users add column if not exists gender text;
alter table public.users add column if not exists date_of_birth date;
alter table public.users add column if not exists marital_status text;
alter table public.users add column if not exists unlocked_achievements text[] default array[]::text[];
alter table public.users add column if not exists duels_won integer default 0;
alter table public.users add column if not exists correct_answers integer default 0;
alter table public.users add column if not exists current_streak integer default 0;
alter table public.users add column if not exists last_login date default current_date;
alter table public.users add column if not exists consumables jsonb default '{}'::jsonb;

-- Renombrar 'mana' a 'fe' si la columna 'mana' existe
do $$
begin
  if exists(select 1 from information_schema.columns where table_name='users' and column_name='mana') then
    alter table public.users rename column mana to fe;
  end if;
end$$;


-- ========= TABLA DE PUBLICACIONES DE LA COMUNIDAD =========
-- Almacena los temas y respuestas del foro.
create table if not exists public.community_posts (
  id uuid primary key default uuid_generate_v4(),
  author jsonb,
  title text,
  content text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  replies jsonb[] default array[]::jsonb[],
  likes integer default 0,
  liked_by uuid[] default array[]::uuid[]
);

-- ========= FUNCIÓN TRIGGER PARA CREAR PERFIL DE USUARIO (SIMPLIFICADA) =========
-- Se ejecuta automáticamente cuando un nuevo usuario se registra en Supabase Auth.
-- Ahora solo maneja los datos simplificados del registro.
create or replace function public.handle_new_user()
returns trigger as $$
begin
  -- El formulario ahora es simplificado. Los datos personales como país, género, etc.,
  -- se añadirán por el usuario más tarde desde su perfil. Las columnas correspondientes
  -- en la base de datos se crearán con valores NULL.
  insert into public.users (uid, email, custom_name, avatar_url, motto_verse, title, is_guest, last_login, current_streak)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'customName', 'Invitado Anónimo'),
    'https://picsum.photos/seed/' || new.id::text || '/100',
    '{"text": "El Señor es mi pastor, nada me faltará.", "reference": "Salmo 23:1"}',
    'Neófito de la Fe',
    (new.raw_app_meta_data->>'provider' = 'anonymous'),
    current_date,
    1
  );
  return new;
end;
$$ language plpgsql security definer;


-- ========= TRIGGER PARA `handle_new_user` =========
-- Asocia la función anterior al evento de creación de un nuevo usuario en `auth.users`.
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- ========= POLÍTICAS DE SEGURIDAD (ROW LEVEL SECURITY) =========

-- --- Políticas para la tabla `users` ---
-- Habilitar RLS
alter table public.users enable row level security;
-- PERMITIR LECTURA: Cualquiera puede ver los perfiles de usuario.
drop policy if exists "Allow public read access to user profiles" on public.users;
create policy "Allow public read access to user profiles" on public.users
  for select using (true);
-- PERMITIR ACTUALIZACIÓN: Los usuarios solo pueden actualizar su propio perfil.
drop policy if exists "Allow users to update their own profile" on public.users;
create policy "Allow users to update their own profile" on public.users
  for update using (auth.uid() = uid);

-- --- Políticas para la tabla `community_posts` ---
-- Habilitar RLS
alter table public.community_posts enable row level security;
-- PERMITIR LECTURA: Cualquiera puede ver las publicaciones.
drop policy if exists "Allow public read access to community posts" on public.community_posts;
create policy "Allow public read access to community posts" on public.community_posts
  for select using (true);
-- PERMITIR INSERCIÓN: Solo los usuarios autenticados pueden crear publicaciones.
drop policy if exists "Allow authenticated users to create posts" on public.community_posts;
create policy "Allow authenticated users to create posts" on public.community_posts
  for insert with check (auth.role() = 'authenticated');
-- PERMITIR ACTUALIZACIÓN: Nadie puede actualizar publicaciones directamente. Se maneja con funciones.
-- (Esto previene que un usuario modifique los "likes" de otro, etc.)
drop policy if exists "Disallow updates to community posts" on public.community_posts;
create policy "Disallow updates to community posts" on public.community_posts
 for update using (false);


-- ========= FUNCIONES RPC (REMOTE PROCEDURE CALL) =========
-- Estas funciones encapsulan la lógica de negocio y se pueden llamar de forma segura desde el frontend.

-- --- Función de AUTO-REPARACIÓN de perfil de usuario ---
create or replace function public.ensure_user_profile_exists(p_user_id uuid)
returns void as $$
declare
  v_email text;
  v_custom_name text;
  v_is_anonymous boolean;
begin
  -- Obtener datos del usuario desde auth.users
  select
    au.email,
    coalesce(au.raw_user_meta_data->>'customName', 'Invitado Anónimo'),
    (au.raw_app_meta_data->>'provider' = 'anonymous')
  into
    v_email,
    v_custom_name,
    v_is_anonymous
  from auth.users as au where au.id = p_user_id;

  -- Intentar insertar el perfil. Si ya existe, no hace nada.
  insert into public.users (uid, email, custom_name, avatar_url, motto_verse, title, is_guest)
  values (
    p_user_id,
    v_email,
    v_custom_name,
    'https://picsum.photos/seed/' || p_user_id::text || '/100',
    '{"text": "El Señor es mi pastor, nada me faltará.", "reference": "Salmo 23:1"}',
    'Neófito de la Fe',
    v_is_anonymous
  )
  on conflict (uid) do nothing;
end;
$$ language plpgsql security definer;


-- --- Función para incrementar estadísticas del usuario ---
-- Se elimina la función existente para permitir el cambio de nombre del parámetro 'mana_inc' a 'fe_inc'.
drop function if exists increment_user_stats(uuid, integer, integer, integer);
create or replace function increment_user_stats(user_id uuid, xp_inc integer, fe_inc integer, talents_inc integer)
returns void as $$
begin
  update public.users
  set
    xp = xp + xp_inc,
    fe = fe + fe_inc,
    talents = talents + talents_inc
  where uid = user_id;
end;
$$ language plpgsql security definer;

-- --- Función para incrementar estadísticas adicionales (duelos, respuestas correctas) ---
create or replace function increment_additional_stats(user_id uuid, duels_won_inc integer, correct_answers_inc integer)
returns void as $$
begin
  update public.users
  set
    duels_won = duels_won + duels_won_inc,
    correct_answers = correct_answers + correct_answers_inc
  where uid = user_id;
end;
$$ language plpgsql security definer;


-- --- Función para añadir una respuesta a una publicación ---
create or replace function add_reply_to_post(p_post_id uuid, p_new_reply jsonb)
returns void as $$
begin
  update public.community_posts
  set replies = array_append(replies, p_new_reply)
  where id = p_post_id;
end;
$$ language plpgsql security definer;

-- --- Función para dar "Me gusta" a una publicación ---
create or replace function like_community_post(p_post_id uuid, p_user_id uuid)
returns void as $$
begin
  update public.community_posts
  set
    likes = likes + 1,
    liked_by = array_append(liked_by, p_user_id)
  where id = p_post_id and not (liked_by @> array[p_user_id]); -- Solo si el usuario no ha dado like antes
end;
$$ language plpgsql security definer;


-- --- Funciones para el sistema de amigos ---

-- 1. Enviar una solicitud de amistad
create or replace function send_friend_request(sender_id uuid, receiver_id uuid)
returns void as $$
begin
  -- Añadir al receptor a la lista de "solicitudes enviadas" del remitente
  update public.users
  set friend_requests_sent = array_append(friend_requests_sent, receiver_id)
  where uid = sender_id;

  -- Añadir al remitente a la lista de "solicitudes recibidas" del receptor
  update public.users
  set friend_requests_received = array_append(friend_requests_received, sender_id)
  where uid = receiver_id;
end;
$$ language plpgsql security definer;

-- 2. Aceptar una solicitud de amistad
create or replace function accept_friend_request(accepter_id uuid, requester_id uuid)
returns void as $$
begin
  -- Añadir al solicitante a la lista de amigos del aceptante
  update public.users
  set friends = array_append(friends, requester_id),
      friend_requests_received = array_remove(friend_requests_received, requester_id)
  where uid = accepter_id;

  -- Añadir al aceptante a la lista de amigos del solicitante
  update public.users
  set friends = array_append(friends, accepter_id),
      friend_requests_sent = array_remove(friend_requests_sent, accepter_id)
  where uid = requester_id;
end;
$$ language plpgsql security definer;

-- 3. Rechazar una solicitud de amistad
create or replace function decline_friend_request(decliner_id uuid, requester_id uuid)
returns void as $$
begin
  -- Eliminar la solicitud de la lista del que la rechaza
  update public.users
  set friend_requests_received = array_remove(friend_requests_received, requester_id)
  where uid = decliner_id;

  -- Eliminar la solicitud de la lista del que la envió
  update public.users
  set friend_requests_sent = array_remove(friend_requests_sent, decliner_id)
  where uid = requester_id;
end;
$$ language plpgsql security definer;

-- 4. Eliminar un amigo
create or replace function remove_friend(remover_id uuid, friend_to_remove_id uuid)
returns void as $$
begin
  -- Eliminar amigo de la lista del que lo elimina
  update public.users
  set friends = array_remove(friends, friend_to_remove_id)
  where uid = remover_id;

  -- Eliminar de la lista de amigos del otro usuario
  update public.users
  set friends = array_remove(friends, remover_id)
  where uid = friend_to_remove_id;
end;
$$ language plpgsql security definer;

-- --- Función para actualizar la racha de inicio de sesión ---
create or replace function update_login_streak(p_user_id uuid)
returns void as $$
declare
  v_last_login date;
  v_current_streak integer;
begin
  select last_login, current_streak into v_last_login, v_current_streak
  from public.users
  where uid = p_user_id;

  if v_last_login < current_date then
    if v_last_login = current_date - interval '1 day' then
      -- Conexión consecutiva
      update public.users
      set last_login = current_date,
          current_streak = v_current_streak + 1
      where uid = p_user_id;
    else
      -- La racha se rompió
      update public.users
      set last_login = current_date,
          current_streak = 1
      where uid = p_user_id;
    end if;
  end if;
end;
$$ language plpgsql security definer;


-- --- Función para obtener la tabla de clasificación ---
create or replace function get_leaderboard(sort_by text)
returns table (
  uid uuid,
  email text,
  custom_name text,
  avatar_url text,
  level integer,
  xp integer,
  title text,
  duels_won integer,
  current_streak integer,
  unlocked_achievements_count integer
) as $$
begin
  return query execute
    'select u.uid, u.email, u.custom_name, u.avatar_url, u.level, u.xp, u.title, u.duels_won, u.current_streak, array_length(u.unlocked_achievements, 1) as unlocked_achievements_count
     from public.users u
     where u.is_guest = false
     order by ' || quote_ident(sort_by) || ' desc, u.custom_name asc
     limit 100';
end;
$$ language plpgsql;

-- --- Función para comprar un consumible ---
create or replace function purchase_consumable(p_user_id uuid, p_item_id text, p_cost integer, p_currency text)
returns void as $$
declare
    current_amount integer;
    new_consumable_count integer;
begin
    -- Decrementar la moneda
    if p_currency = 'fe' then
        update public.users set fe = fe - p_cost where uid = p_user_id and fe >= p_cost;
    elsif p_currency = 'talents' then
        update public.users set talents = talents - p_cost where uid = p_user_id and talents >= p_cost;
    end if;

    -- Incrementar el consumible
    select coalesce((consumables->>p_item_id)::integer, 0) into current_amount from public.users where uid = p_user_id;
    new_consumable_count := current_amount + 1;

    update public.users
    set consumables = consumables || jsonb_build_object(p_item_id, new_consumable_count)
    where uid = p_user_id;
end;
$$ language plpgsql security definer;

-- --- Función para usar un consumible ---
create or replace function use_consumable(p_user_id uuid, p_item_id text)
returns void as $$
declare
    current_amount integer;
    new_consumable_count integer;
begin
    select coalesce((consumables->>p_item_id)::integer, 0) into current_amount from public.users where uid = p_user_id;
    
    if current_amount > 0 then
        new_consumable_count := current_amount - 1;
        update public.users
        set consumables = consumables || jsonb_build_object(p_item_id, new_consumable_count)
        where uid = p_user_id;
    end if;
end;
$$ language plpgsql security definer;


-- #############################################################################
-- #                                                                           #
-- #                     FIN DEL SCRIPT DE CONFIGURACIÓN                       #
-- #                                                                           #
-- #############################################################################